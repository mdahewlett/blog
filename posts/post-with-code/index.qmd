---
title: "Fixing factory machines faster with LLMs"
author: "Michael Hewlett"
date: "2025-01-15"
categories: [code, analysis]
image: "image.jpg"
---

## Introduction
When a machine breaks down in a factory, a technician comes to fix it. The faster they fix it, the sooner the factory is making products. But the machine manuals that technicians need to use to fix the machines are thousands of pages long. To help them find the right information faster, I built a QA (question-answer) tool that uses LLMs. But LLMs have a limit to the amount of information they can consider when answering a user’s query - this is called their context window. Being thousands of pages long, the manuals are too large for this context window. Normally AI engineers solve this by breaking the manual into pieces, finding the most relevant piece for the user’s question, then using it to answer the question, but in November 2024 Google released Gemini Pro 1.5 with a context window long enough to take in thousands of pages. So I built the tool using that model and here I’ll walk through how I built it and end with how well the tool works.

## Installations
First we install the necessary packages. The google-generativeai library allows us to interact with Google's Generative AI models, and pdf2image along with poppler-utils converts PDF documents into images for processing. The imports are for utility functions later on.

[THAT CODE]


## API Keys
Next we got API keys and set them up for our conntections to google’s API.

[THAT CODE]

## Converting PDFs to Images
Then we converted the PDF of manual into individual images since the model cannot take PDFs as input.

[THAT CODE]

## Uploading Images to Google's AI Platform
We uploaded those images using the Files API. This lets the manual to be used across different queries. It speeds things up since the files don’t need to be uploaded each time a user asks a question.

[THAT CODE]

## Adding Page Numbers
Our manual did not have clear page numbers so I used a hack that would make this clear to the model.

[THAT CODE]

## Caching
Next we cached the manual and invoked the model. This stores the pages that we uploaded in a place where they can be accessed faster and used more cheaply.

In terms of cost, you are charged by how much information you give the model, and how much text the model generates. Information that you give the model that is cached is charged at a lower rate, so if you are regularly giving the model the same information, it can be cheaper to cache this. Checkout the documentation around context caching here: https://ai.google.dev/gemini-api/docs/caching?hl=en&lang=python

[THAT CODE]

## Prompting
Now is the main prompt, where we tell the LLM what input it gets and what output we want. There were 5 techniques we used because we noticed that the output wasn’t what we wanted, so we added each technique to solve an issue we had with the output. First we found that the model would stop looking through the manual once it found an answer, but we wanted to make sure it found all relevant pages, so we told it to scan through in 10 page sections for the whole document, then decide what pages were relevant. This is call full document chain-of-thought. Next we found that when the needed information was in a table, the model would find the right table but pull information from the wrong cell, so we told it to extract all the information from page into its own format, then extract the piece of information, which worked. Next the models are stochastic and can make mistakes, so we asked it to check its work. Next, since the model output would be more than what we want to show the user, we asked it to include the information that we wanted to show the user in XML tags so we could later use REGEX to easily extract the answer. Last, we give the model a few examples of the output we want - this is called few-shot prompting.

[CODE]

## Adding utility Functions
Next are 3 utility functions. A utility function is code that supports the main function, but isn’t the special sauce. The first function extract_answers_from_text() extracts the final answer and page references from the model response. The second function display_selected_pages() displays the relevant pages to the user. The third function get_answer_from_manual() calls the model, then uses the 2 utility functions to give the user an answer.

That is how it works, next I’ll tell you what it works for then cover limitations.

[CODE]

## Using the Tool
Below are examples of the tool in use.

What I did here is important, you actually decide what queries you want it to handle then use that to assess how well it works.
Anything a technician wants to know has a location and a format. 
Information in the manual has a location and a format. Sometimes a technician just wants the location, or just the information, or a specific format. So we made the tool to be able to handle these types of queries. Because the manual we were working off of had a lot of information in textual procedurals, and diagrams of exploded schematics, we 

Query 1: Looking for location
In the example below, 


We thought through what kinds of queries a technician would have and tested the 4 most frequent query types:

The technician wants to know where information is in the manual
The technician is looking for a procedure
The technician is looking for a diagram
The technician is looking for a detail
Information in machine manuals is often multimodal, containing text and images. In some cases a technician doesn't care what mode the information comes in (query types 1 and 4), in others they are looking for a specific mode (query types 2 and 3).

In this demonstration's manual, the modes are procedures, data tables, and a host of visuals like exploded schematics, circuit diagrams, and troubleshooting flow charts. Since the majority of the manual's content is procedures and exploded schematics, we focused on those examples

[CODE]

## Performance and Limitations

The point of the tool is find information for technicians faster. The QA tool does well on finding the right information. The technicians I talked to say that they either have a physical manul, or use ctrl+F in a PDF to search for keywords. This tool works better than keyword search because it also lets technicians search by images or diagrams that have no associated text, that could not have been found with the normal method. On the other side, the tool takes about 1 minute to generate a response so it fails to find the information for technicians faster. One solution I am working on is RAG since there would be less information for the model to process in generating an answer, so response time should be faster. The second limitation is reliability. We have examples, but don’t know how often it is right or wrong. To address this we’ll make a bunch of example queries and correct responses in the different query types, then run the tests multiple times to score the precision and recall of the model. This will let us talk about how good the tool isand when we make changes, to what extent is has improved.

## Conclusion
May need to write